(function () {
'use strict';

function __$styleInject(css, returnValue) {
  if (typeof document === 'undefined') {
    return returnValue;
  }
  css = css || '';
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  head.appendChild(style);
  
  if (style.styleSheet){
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
  return returnValue;
}

function step(obj, target) {
  // total height = 500


  if (target != null && target instanceof Array) {
    var targetlen = target.length;
    for (var num = 0; num < targetlen; num++) {
      if (obj.ballid === target[num].ballid) continue;
      mutualcollision(obj, target[num]);
    }
  }

  /// check collide with wall
  if (iscollide(obj.bb_x, obj.vx, obj.dirx, obj.bb_r)) {
    obj.dirx = -obj.dirx;
  }
  if (iscollide(obj.bb_y, obj.vy, obj.diry, obj.bb_r)) {
    obj.diry = -obj.diry;
  }
  //prevent floating x, y from drawing unclear images
  obj.bb_x += round(obj.dirx * obj.vx);
  obj.bb_y += round(obj.diry * obj.vy);
}
//round number
function round(num) {
  return 0.5 + num << 0;
}
// width = height = 500
function iscollide(d, v, dir, r) {
  var dd = d + v * dir;
  return dd >= 500 - r || dd <= r;
}

function isballcollide(source, target) {
  var s = source;
  var t = target;
  var dx2 = Math.pow(s.bb_x - t.bb_x, 2);
  var dy2 = Math.pow(s.bb_y - t.bb_y, 2);
  var d = Math.sqrt(dx2 + dy2);
  return d < s.bb_r + t.bb_r;
}
function mutualcollision(source, target) {
  if (isballcollide(source, target)) {
    //hp -= 10;
    exchange(source, target);
  }
  //return hp;
}
//ELASTIC and obj1 and obj2 mass are equal
function exchange(obj1, obj2) {
  var temp1 = obj2.vx;
  var temp2 = obj2.vy;
  var tempdirx = obj2.dirx;
  var tempdiry = obj2.diry;
  obj2.vx = obj1.vx;
  obj2.vy = obj1.vy;
  obj2.dirx = obj1.dirx;
  obj2.diry = obj1.diry;

  obj1.vx = temp1;
  obj1.vy = temp2;
  obj1.dirx = tempdirx;
  obj1.diry = tempdiry;
}

function create(ctx, x, y, r) {
  var color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "green";

  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2, false);
  ctx.fillStyle = color;
  ctx.fill();
  ctx.closePath();
}

function clear(ctx) {
  ctx.clearRect(0, 0, 500, 500);
}

function transaction(ctx, move) {
  ctx.restore();
  /* 
    include all you want
    create and move
  */

  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  create.apply(undefined, [ctx].concat(args));
  move();
  ctx.save();
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

function xyrValidate() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var x = args[0],
      y = args[1],
      r = args[2];

  var message = null;
  if (typeof x === "Number" && typeof y === "Number" && typeof z === "Number") message = "Must be Number";
  if (x < 0 || y < 0) message = "Number must be Positive";
  if (x < r || y < r) message = "Initial position error";

  if (message !== null) throw new BaseError(message);
}

function ballstickyValidate(source, target) {
  //detected
  if (isballcollide(source, target)) {
    throw new BaseError("Initial position error: source:" + source.ballid + "; target: " + target.ballid + "; they are sticky");
  }
}

//SyntaxError

var BaseError = function (_Error) {
  inherits(BaseError, _Error);

  function BaseError() {
    var _ref;

    classCallCheck(this, BaseError);

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var _this = possibleConstructorReturn(this, (_ref = BaseError.__proto__ || Object.getPrototypeOf(BaseError)).call.apply(_ref, [this].concat(args)));

    Error.captureStackTrace(_this, BaseError);
    return _this;
  }

  return BaseError;
}(Error);

var BB = function () {
  function BB(ctx) {
    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 240;
    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 160;
    var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
    var color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "red";
    var ballid = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : "";
    var dirx = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 1;
    var diry = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 1;
    var hp = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 100;
    var detected = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : false;
    classCallCheck(this, BB);

    xyrValidate(x, y, r);
    this.bb_x = x;
    this.bb_y = y;
    this.bb_r = r;
    this.dirx = dirx;
    this.diry = diry;
    this.vx = 8;
    this.vy = 8;
    this.color = color;
    this.hp = hp;
    this.detected = detected;
    this.ballid = ballid;
    create(ctx, this.bb_x, this.bb_y, this.bb_r, this.color);
  }

  createClass(BB, [{
    key: "move",
    value: function move(targets) {
      step(this, targets);
    }
  }, {
    key: "render",
    value: function render(ctx, targets) {
      transaction(ctx, this.move.bind(this, targets), this.bb_x, this.bb_y, this.bb_r, this.color);
    }
  }]);
  return BB;
}();

function generateballs(ctx, states) {
  var balls = [];
  for (var i = 0; i < states.length; i++) {
    var state_i = states[i];
    var newball = new BB(ctx, state_i.x, state_i.y, state_i.r, state_i.color, "ball_level_" + i, state_i.dirx, state_i.diry);
    // check initial position between balls, and exclude no sticky balls around
    balls.push(newball);
    for (var j = 1; j < balls.length; j++) {
      ballstickyValidate(balls[j - 1], newball);
    }
  }
  return balls;
}

__$styleInject(".root{margin:0}canvas{background:#000}#left,#right{float:left}#right{margin-left:30;width:15rem}#score{font-size:1rem}", undefined);

var canvas = document.getElementById("gm5");
var scoreHtml = document.getElementById("score");
var ctx = canvas.getContext("2d");
var cancelId = null;

// record ball position states
////
function random_int_range(min, max) {
  if (max <= min) throw new TypeError("max must be larger than min");
  return Math.floor(Math.random() * (max - min + 1)) + min;
}
function generate_states() {
  var states = [];
  var colors = ["blue", "red", "green", "pink"];
  // let colors = ["blue", "red"];
  var dirs = [1, -1];
  var r = 15;
  var y = 0;
  var x = 0;
  var boundry = 500;
  var num = Math.floor(boundry / r - 1);
  for (var i = 1; i <= num; i++) {
    x = r + (2 * i - 1) * r;
    for (var j = 1; j <= num; j++) {
      y = r + (2 * j - 1) * r;
      states.push({
        x: x,
        y: y,
        r: r,
        color: colors[random_int_range(0, colors.length)],
        dirx: dirs[random_int_range(0, 1)],
        diry: dirs[random_int_range(0, 1)]
      });
    }
  }
  return states;
}
// var states = [
//   { x: 30, y: 160, r: 20, color: "blue" },
//   { x: 70, y: 60, r: 20, color: "red" },
//   { x: 150, y: 60, r: 20, color: "green" },
//   { x: 50, y: 100, r: 20, color: "pink" }
// ];
var states = generate_states();
var balls = generateballs(ctx, states);
//const mybb1controller = controller(mybb1);
/////
function register() {
  //if (!isRegistered) {
  window.addEventListener("keydown", function (evt) {
    //console.log(e.keyCode);
    // when keydown event emit, stepx(), stepy() should change direction
    // as the keydown arrow key
    // note: it should follow the boundary rule.
    switch (evt.keyCode) {
      case 37:
        mybb1controller.left();
        break;
      case 38:
        mybb1controller.up();
        break;
      case 39:
        mybb1controller.right();
        break;
      case 40:
        mybb1controller.down();
        break;
      // case 32: //SPACE (stop)
      //   stop();
      //   break;
      // case 13: //ENTER (start)
      //   start();
      //   break;
    }
  }, false);

  //isRegistered = true;

  // stop recover isRegistered false
  //}
}

// let state = {
//   bb1: { x: bb1.bb_x, y: bb1.bb_y, r: bb1.bb_r, hp: bb1.hp },
//   mybb1: { x: mybb1.bb_x, y: mybb1.bb_y, r: mybb1.bb_r, hp: mybb1.hp },
// };
// function stop(cancelId) {
//   cancelAnimationFrame(cancelId);
// }

//////////RELOAD
//HP: 100/ Red: 2
/////////

function start() {
  clear(ctx);
  for (var num = 0; num < balls.length; num++) {
    balls[num].render(ctx, balls);
  }
  //mybb1.render(ctx, null);
  // bb1.hp > 0 ? bb1.render(ctx, gb1) : null;
  // bb2.hp > 0 ? bb2.render(ctx, gb1) : null;
  // mybb1.hp > 0 ? mybb1.render(ctx, null) : null;
  //let red = 2 - (bb1.hp > 0 ? 0 : 1) - (bb2.hp > 0 ? 0 : 1);
  //if (red === 0) red += "\nDONE! PLEASE REFRESH(F5)"
  //scoreHtml.innerHTML = `HP: ${bb1.hp + bb2.hp}/ RED: ${red}`;
  cancelId = requestAnimationFrame(start);
}

register();
//start();
setTimeout(start, 500);

// when to end?
// cancelAnimationFrame(cancelId);
// hp  100 -> 150 => win
// hp  100 -> 0  => lose

}());
