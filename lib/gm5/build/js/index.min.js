(function () {
'use strict';

function __$styleInject(css, returnValue) {
  if (typeof document === 'undefined') {
    return returnValue;
  }
  css = css || '';
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  head.appendChild(style);
  
  if (style.styleSheet){
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
  return returnValue;
}

function stepx(x, dx, dirx, r) {
  // total width = 500

  if (x + dx > 500 - r || x + dx < r) {
    dirx = -dirx;
  }
  return dirx * dx;
}

function stepy(y, dy, diry, r) {
  // total height = 500

  if (y + dy > 500 - r || y + dy < r) {
    diry = -diry;
  }
  return diry * dy;
}

function step(d, dd, dir, r) {
  // total height = 500

  if (d + dd > 500 - r || d + dd < r) {
    dir = -dir;
  }
  return dir * dd;
}



function mutualcollision(source, target) {
  var bb1 = source;
  var gb1 = target;
  var dx2 = Math.pow(gb1.gb_x - bb1.bb_x, 2);
  var dy2 = Math.pow(gb1.gb_y - bb1.bb_y, 2);
  var d = Math.sqrt(dx2 + dy2);
  var hp = bb1.hp;

  //detected collision
  if (d < gb1.gb_r + bb1.bb_r) {
    hp -= 10;
  }
  return hp;
}

function create(ctx, x, y, r) {
  var color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "green";

  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2, false);
  ctx.fillStyle = color;
  ctx.fill();
  ctx.closePath();
}

function clear(ctx) {
  ctx.clearRect(0, 0, 500, 500);
}

function transaction(ctx, move) {
  ctx.restore();
  /* 
    include all you want
     create and move
  */

  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  create.apply(undefined, [ctx].concat(args));
  move();
  ctx.save();
}

function xyrError(x, y, r) {
  if (typeof x === "Number" && typeof y === "Number" && typeof z === "Number") throw new Error("Must be Number");
  if (x < 0 || y < 0) throw new Error("Number must be Positive");
  if (x < r || y < r) throw new Error("Initial position error");
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

// gb - good ball

var GB = function () {
  function GB(ctx) {
    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 240;
    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 160;
    var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
    var hp = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 100;
    classCallCheck(this, GB);

    xyrError(x, y, r);
    this.gb_x = x;
    this.gb_y = y;
    this.gb_r = r;
    this.vx = 3;
    this.vy = -3;
    this.hp = hp;
    create(ctx, this.gb_x, this.gb_y, this.gb_r);
  }

  createClass(GB, [{
    key: "move",
    value: function move() {
      this.vx = stepx(this.gb_x, this.vx, this.gb_r);
      this.vy = stepy(this.gb_y, this.vy, this.gb_r);
      this.gb_x += this.vx;
      this.gb_y += this.vy;
    }
  }, {
    key: "render",
    value: function render(ctx) {
      transaction(ctx, this.move.bind(this), this.gb_x, this.gb_y, this.gb_r);
    }
  }]);
  return GB;
}();

// mp - magic power

// bb - bad ball


var BB = function () {
  function BB(ctx) {
    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 240;
    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 160;
    var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
    var color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "red";
    var hp = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;
    var detected = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    classCallCheck(this, BB);

    xyrError(x, y, r);
    this.bb_x = x;
    this.bb_y = y;
    this.bb_r = r;
    this.dirx = -1;
    this.diry = 1;
    this.vx = 1;
    this.vy = 1;
    this.color = color;
    this.hp = hp;
    this.detected = detected;
    create(ctx, this.bb_x, this.bb_y, this.bb_r, this.color);
  }

  createClass(BB, [{
    key: "move",
    value: function move(controller) {
      //arrow key
      this.bb_x += step(this.bb_x, this.vx, this.dirx, this.bb_r);
      this.bb_y += step(this.bb_y, this.vy, this.diry, this.bb_r);
    }
  }, {
    key: "render",
    value: function render(ctx) {
      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var controller = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      transaction(ctx, this.move.bind(this, controller), this.bb_x, this.bb_y, this.bb_r, this.color);
      this.collision(this, target);
    }
  }, {
    key: "collision",
    value: function collision(source, target) {
      if (this.detected && target !== null) {
        this.hp = mutualcollision(source, target);
      }
    }
  }]);
  return BB;
}();

__$styleInject(".root{margin:0}canvas{background:#000}#left,#right{float:left}#right{margin-left:30;width:15rem}#score{font-size:1rem}", undefined);

var canvas = document.getElementById("gm5");
var scoreHtml = document.getElementById("score");
var ctx = canvas.getContext("2d");
var cancelId = null;

// record ball position states


var gb1 = new GB(ctx, 100, 50);
var gb2 = new GB(ctx, 80, 40);
var bb1 = new BB(ctx, 50, 100, 20, "red", 300, true);
var bb2 = new BB(ctx, 150, 40, 20, "red", 200, true);
var mybb1 = new BB(ctx, 30, 30, 30, "yellow", 100);

var isRegistered = false;
//maxVx
//maxVy
//define its a(acceleration)

//original a = 0
//keybinding
function isdiffdir(fdir, selfdir) {
  return fdir * selfdir < 0;
}

function setvx(self, fdir, fx, maxVx) {
  var dv = fx * self.vx;
  if (isdiffdir(fdir, self.dirx)) {
    self.dirx = fdir;
    if (self.vx - dv > 0) {
      self.vx -= dv;
    }
    return;
  }
  if (self.vx + dv < maxVx) self.vx += dv;
}

function setvy(self, fdir, fy, maxVy) {
  var dv = fy * self.vy;

  if (isdiffdir(fdir, self.diry)) {
    self.diry = fdir;
    if (self.vy - dv > 0) {
      self.vy -= dv;
    }
    return;
  }
  if (self.vy + dv < maxVy) self.vy += fy * self.vy;
}

function controller(obj) {
  var self = obj;

  // scalr
  var fx = 1;
  var fy = 1;
  var maxVx = 5;
  var maxVy = 5;
  return {
    left: setvx.bind(self, self, -1, fx, maxVx),
    right: setvx.bind(self, self, 1, fx, maxVx),
    up: setvy.bind(self, self, -1, fy, maxVy),
    down: setvy.bind(self, self, 1, fy, maxVy)
  };
}
var mybb1controller = controller(mybb1);

function register() {
  if (!isRegistered) {
    window.addEventListener("keydown", function (evt) {
      //console.log(e.keyCode);
      // when keydown event emit, stepx(), stepy() should change direction
      // as the keydown arrow key
      // note: it should follow the boundary rule.
      switch (evt.keyCode) {
        case 37:
          mybb1controller.left();
          break;
        case 38:
          mybb1controller.up();
          break;
        case 39:
          mybb1controller.right();
          break;
        case 40:
          mybb1controller.down();
          break;
        // case 32: //SPACE (stop)
        //   stop();
        //   break;
        // case 13: //ENTER (start)
        //   start();
        //   break;
      }
    }, false);

    isRegistered = true;

    // stop recover isRegistered false
  }
}

// let state = {
//   gb1: { x: gb1.gb_x, y: gb1.gb_y, r: gb1.gb_r },
//   gb2: { x: gb2.gb_x, y: gb2.gb_y, r: gb2.gb_r },
//   bb1: { x: bb1.bb_x, y: bb1.bb_y, r: bb1.bb_r, hp: bb1.hp },
//   mybb1: { x: mybb1.bb_x, y: mybb1.bb_y, r: mybb1.bb_r, hp: mybb1.hp },
// };
// function stop(cancelId) {
//   cancelAnimationFrame(cancelId);
// }


//HP: 100/ Red: 2

function start() {
  register();
  clear(ctx);
  gb1.render(ctx);
  gb2.render(ctx);
  bb1.hp > 0 ? bb1.render(ctx, gb1) : null;
  bb2.hp > 0 ? bb2.render(ctx, gb1) : null;
  mybb1.hp > 0 ? mybb1.render(ctx, null, mybb1controller) : null;
  //let red = 2 - (bb1.hp > 0 ? 0 : 1) - (bb2.hp > 0 ? 0 : 1);
  //if (red === 0) red += "\nDONE! PLEASE REFRESH(F5)"
  //scoreHtml.innerHTML = `HP: ${bb1.hp + bb2.hp}/ RED: ${red}`;
  cancelId = requestAnimationFrame(start);
}

//register();
start();

// when to end?
// cancelAnimationFrame(cancelId);
// hp  100 -> 150 => win
// hp  100 -> 0  => lose

}());
