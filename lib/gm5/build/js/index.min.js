(function () {
'use strict';

function __$styleInject(css, returnValue) {
  if (typeof document === 'undefined') {
    return returnValue;
  }
  css = css || '';
  var head = document.head || document.getElementsByTagName('head')[0];
  var style = document.createElement('style');
  style.type = 'text/css';
  head.appendChild(style);
  
  if (style.styleSheet){
    style.styleSheet.cssText = css;
  } else {
    style.appendChild(document.createTextNode(css));
  }
  return returnValue;
}

function step(d, v, dirVal, r, dirKey, obj) {
  // total height = 500
  if (iscollide(d, v, dirVal, r)) {
    dirVal = -dirVal;
    obj[dirKey] = dirVal;
  }
  return dirVal * v;
}

// width = height = 500
function iscollide(d, v, dir, r) {
  var dd = d + v * dir;
  return dd >= 500 - r || dd <= r;
}

function mutualcollision(source, target) {
  var bb1 = source;
  var gb1 = target;
  var dx2 = Math.pow(gb1.gb_x - bb1.bb_x, 2);
  var dy2 = Math.pow(gb1.gb_y - bb1.bb_y, 2);
  var d = Math.sqrt(dx2 + dy2);
  var hp = bb1.hp;

  //detected collision
  if (d < gb1.gb_r + bb1.bb_r) {
    hp -= 10;
  }
  return hp;
}

function create(ctx, x, y, r) {
  var color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "green";

  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2, false);
  ctx.fillStyle = color;
  ctx.fill();
  ctx.closePath();
}

function clear(ctx) {
  ctx.clearRect(0, 0, 500, 500);
}

function transaction(ctx, move) {
  ctx.restore();
  /* 
    include all you want
     create and move
  */

  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  create.apply(undefined, [ctx].concat(args));
  move();
  ctx.save();
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();









var inherits = function (subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
};











var possibleConstructorReturn = function (self, call) {
  if (!self) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return call && (typeof call === "object" || typeof call === "function") ? call : self;
};

function xyrValiate() {
  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var x = args[0],
      y = args[1],
      r = args[2];

  var message = null;
  if (typeof x === "Number" && typeof y === "Number" && typeof z === "Number") message = "Must be Number";
  if (x < 0 || y < 0) message = "Number must be Positive";
  if (x < r || y < r) message = "Initial position error";

  if (message !== null) throw new BaseError(message);
}

//SyntaxError

var BaseError = function (_Error) {
  inherits(BaseError, _Error);

  function BaseError() {
    var _ref;

    classCallCheck(this, BaseError);

    for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    var _this = possibleConstructorReturn(this, (_ref = BaseError.__proto__ || Object.getPrototypeOf(BaseError)).call.apply(_ref, [this].concat(args)));

    Error.captureStackTrace(_this, BaseError);
    return _this;
  }

  return BaseError;
}(Error);

// gb - good ball

var GB = function () {
  function GB(ctx) {
    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 240;
    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 160;
    var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
    var hp = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 100;
    classCallCheck(this, GB);

    xyrValiate(x, y, r);
    this.gb_x = x;
    this.gb_y = y;
    this.gb_r = r;
    this.vx = 3;
    this.vy = 3;
    this.dirx = 1;
    this.diry = 1;
    this.hp = hp;
    create(ctx, this.gb_x, this.gb_y, this.gb_r);
  }

  createClass(GB, [{
    key: "move",
    value: function move() {
      this.gb_x += step(this.gb_x, this.vx, this.dirx, this.gb_r, "dirx", this);
      this.gb_y += step(this.gb_y, this.vy, this.diry, this.gb_r, "diry", this);
    }
  }, {
    key: "render",
    value: function render(ctx) {
      transaction(ctx, this.move.bind(this), this.gb_x, this.gb_y, this.gb_r);
    }
  }]);
  return GB;
}();

// mp - magic power
/////////////
// bb - bad ball


var BB = function () {
  function BB(ctx) {
    var x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 240;
    var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 160;
    var r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
    var color = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "red";
    var hp = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;
    var detected = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
    classCallCheck(this, BB);

    xyrValiate(x, y, r);
    this.bb_x = x;
    this.bb_y = y;
    this.bb_r = r;
    this.dirx = -1;
    this.diry = 1;
    this.vx = 1;
    this.vy = 1;
    this.color = color;
    this.hp = hp;
    this.detected = detected;
    create(ctx, this.bb_x, this.bb_y, this.bb_r, this.color);
  }

  createClass(BB, [{
    key: "move",
    value: function move() {
      this.bb_x += step(this.bb_x, this.vx, this.dirx, this.bb_r, "dirx", this);
      this.bb_y += step(this.bb_y, this.vy, this.diry, this.bb_r, "diry", this);
    }
  }, {
    key: "render",
    value: function render(ctx) {
      var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      transaction(ctx, this.move.bind(this), this.bb_x, this.bb_y, this.bb_r, this.color);
      this.collision(this, target);
    }
  }, {
    key: "collision",
    value: function collision(source, target) {
      if (this.detected && target !== null) {
        this.hp = mutualcollision(source, target);
      }
    }
  }]);
  return BB;
}();

__$styleInject(".root{margin:0}canvas{background:#000}#left,#right{float:left}#right{margin-left:30;width:15rem}#score{font-size:1rem}", undefined);

var canvas = document.getElementById("gm5");
var scoreHtml = document.getElementById("score");
var ctx = canvas.getContext("2d");
var cancelId = null;

// record ball position states
////

var gb1 = new GB(ctx, 100, 50);
var gb2 = new GB(ctx, 80, 40);
var bb1 = new BB(ctx, 30, 100, 20, "red", 300, true);
var bb2 = new BB(ctx, 150, 60, 20, "red", 200, true);
var mybb1 = new BB(ctx, 30, 30, 30, "yellow", 100);

//maxVx
//maxVy
//define its a(acceleration)

//original a = 0
//keybinding
function isdiffdir(fdir, selfdir) {
  return fdir * selfdir < 0;
}

// f=ma; m=1 ...
// f=a
function setvx(self, fdir, fx, maxVx) {
  var dv = fx;
  console.log(self.vx);
  // check if collided first
  if (!isdiffdir(fdir, self.dirx) && iscollide(self.bb_x, self.vx, self.dirx, self.bb_r)) {
    self.dirx = -self.dirx;
    return;
  }
  ///
  if (isdiffdir(fdir, self.dirx)) {
    self.dirx = fdir;
    if (self.vx - dv >= 0) {
      self.vx -= dv;
    }
    return;
  }
  if (self.vx + dv <= maxVx) {
    self.vx += dv;
  }
}

function setvy(self, fdir, fy, maxVy) {
  var dv = fy;

  if (!isdiffdir(fdir, self.diry) && iscollide(self.bb_y, self.vy, self.diry, self.bb_r)) {
    self.diry = -self.diry;
    return;
  }

  if (isdiffdir(fdir, self.diry)) {
    self.diry = fdir;
    if (self.vy - dv >= 0) {
      self.vy -= dv;
    }
    return;
  }
  if (self.vy + dv <= maxVy) {
    self.vy += dv;
  }
}

function controller(obj) {
  var self = obj;

  // scalr
  var fx = 1;
  var fy = 1;
  var maxVx = 5;
  var maxVy = 5;
  return {
    left: setvx.bind(self, self, -1, fx, maxVx),
    right: setvx.bind(self, self, 1, fx, maxVx),
    up: setvy.bind(self, self, -1, fy, maxVy),
    down: setvy.bind(self, self, 1, fy, maxVy)
  };
}
var mybb1controller = controller(mybb1);
/////
function register() {
  //if (!isRegistered) {
  window.addEventListener("keydown", function (evt) {
    //console.log(e.keyCode);
    // when keydown event emit, stepx(), stepy() should change direction
    // as the keydown arrow key
    // note: it should follow the boundary rule.
    switch (evt.keyCode) {
      case 37:
        mybb1controller.left();
        break;
      case 38:
        mybb1controller.up();
        break;
      case 39:
        mybb1controller.right();
        break;
      case 40:
        mybb1controller.down();
        break;
      // case 32: //SPACE (stop)
      //   stop();
      //   break;
      // case 13: //ENTER (start)
      //   start();
      //   break;
    }
  }, false);

  //isRegistered = true;

  // stop recover isRegistered false
  //}
}

// let state = {
//   gb1: { x: gb1.gb_x, y: gb1.gb_y, r: gb1.gb_r },
//   gb2: { x: gb2.gb_x, y: gb2.gb_y, r: gb2.gb_r },
//   bb1: { x: bb1.bb_x, y: bb1.bb_y, r: bb1.bb_r, hp: bb1.hp },
//   mybb1: { x: mybb1.bb_x, y: mybb1.bb_y, r: mybb1.bb_r, hp: mybb1.hp },
// };
// function stop(cancelId) {
//   cancelAnimationFrame(cancelId);
// }

//////////RELOAD
//HP: 100/ Red: 2
/////////
function start() {
  clear(ctx);
  gb1.render(ctx);
  gb2.render(ctx);
  bb1.render(ctx, gb1);
  bb2.render(ctx, gb1);
  mybb1.render(ctx, null);
  // bb1.hp > 0 ? bb1.render(ctx, gb1) : null;
  // bb2.hp > 0 ? bb2.render(ctx, gb1) : null;
  // mybb1.hp > 0 ? mybb1.render(ctx, null) : null;
  //let red = 2 - (bb1.hp > 0 ? 0 : 1) - (bb2.hp > 0 ? 0 : 1);
  //if (red === 0) red += "\nDONE! PLEASE REFRESH(F5)"
  //scoreHtml.innerHTML = `HP: ${bb1.hp + bb2.hp}/ RED: ${red}`;
  cancelId = requestAnimationFrame(start);
}

register();
//start();
setTimeout(start, 500);

// when to end?
// cancelAnimationFrame(cancelId);
// hp  100 -> 150 => win
// hp  100 -> 0  => lose

}());
