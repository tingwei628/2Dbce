{"version":3,"file":"index.min.js","sources":["../../src/helpers/movehelpers.js","../../src/helpers/ctxhelpers.js","../../src/errors/error.js","../../src/index.js","../../src/objects/index.js"],"sourcesContent":["export function step(d, v, dirVal, r, dirKey, obj) {\n  // total height = 500\n  if (iscollide(d, v, dirVal, r)) {\n    dirVal = -dirVal;\n    obj[dirKey] = dirVal;\n  }\n  return dirVal * v;\n}\n\n// width = height = 500\nexport function iscollide(d, v, dir, r) {\n  let dd = d + v * dir;\n  return (dd >= (500 - r)) || (dd <= r);\n}\n\n\nexport function mutualcollision(source, target, state = null) {\n  let bb1 = source;\n  let gb1 = target;\n  let dx2 = Math.pow(gb1.gb_x - bb1.bb_x, 2);\n  let dy2 = Math.pow(gb1.gb_y - bb1.bb_y, 2);\n  let d = Math.sqrt(dx2 + dy2);\n  let hp = bb1.hp;\n\n  //detected collision\n  if (d < gb1.gb_r + bb1.bb_r) {\n    hp -= 10;\n  }\n  return hp;\n}","export function create(ctx, x, y, r, color = \"green\") {\n  ctx.beginPath();\n  ctx.arc(x, y, r, 0, Math.PI * 2, false);\n  ctx.fillStyle = color;\n  ctx.fill();\n  ctx.closePath();\n}\n\nexport function clear(ctx) {\n  ctx.clearRect(0, 0, 500, 500);\n}\n\nexport function transaction(ctx, move, ...args) {\n  ctx.restore();\n  /* \n    include all you want\n     create and move\n  */\n  create(ctx, ...args);\n  move();\n  ctx.save();\n}\n","export function xyrValiate(...args) {\n  const [x, y, r] = args;\n  let message = null;\n  if (typeof (x) === \"Number\" && typeof (y) === \"Number\" && typeof (z) === \"Number\")\n    message = \"Must be Number\";\n  if (x < 0 || y < 0)\n    message = \"Number must be Positive\";\n  if (x < r || y < r)\n    message = \"Initial position error\";\n\n\n  if (message !== null)\n    throw new BaseError(message);\n}\n\n\n//SyntaxError\nclass BaseError extends Error {\n  constructor(...args) {\n    super(...args);\n    Error.captureStackTrace(this, BaseError)\n  }\n}\n","import { GB, BB } from \"./objects\";\nimport \"./styles/main.css\";\nimport { clear } from \"./helpers/ctxhelpers\";\nimport { iscollide } from \"./helpers/movehelpers\";\n\n\nconst canvas = document.getElementById(\"gm5\");\nconst scoreHtml = document.getElementById(\"score\");\nconst ctx = canvas.getContext(\"2d\");\nlet cancelId = null;\n\n// record ball position states\n////\n\nlet gb1 = new GB(ctx, 100, 50);\nlet gb2 = new GB(ctx, 80, 40);\nlet bb1 = new BB(ctx, 30, 100, 20, \"red\", 300, true);\nlet bb2 = new BB(ctx, 150, 60, 20, \"red\", 200, true);\nlet mybb1 = new BB(ctx, 30, 30, 30, \"yellow\", 100);\n\nlet isRegistered = false;\n//maxVx\n//maxVy\n//define its a(acceleration)\n\n//original a = 0\n//keybinding\nfunction isdiffdir(fdir, selfdir) {\n  return fdir * selfdir < 0;\n}\n\n\n\n\n// f=ma; m=1 ...\n// f=a\nfunction setvx(self, fdir, fx, maxVx) {\n  let dv = fx;\n  console.log(self.vx);\n  // check if collided first\n  if (!isdiffdir(fdir, self.dirx) &&\n    iscollide(self.bb_x, self.vx, self.dirx, self.bb_r)) {\n    self.dirx = -self.dirx;\n    return;\n  }\n  ///\n  if (isdiffdir(fdir, self.dirx)) {\n    self.dirx = fdir;\n    if (self.vx - dv >= 0) {\n      self.vx -= dv;\n    }\n    return;\n  }\n  if (self.vx + dv <= maxVx) {\n    self.vx += dv;\n  }\n}\n\nfunction setvy(self, fdir, fy, maxVy) {\n  let dv = fy;\n\n  if (!isdiffdir(fdir, self.diry) &&\n    iscollide(self.bb_y, self.vy, self.diry, self.bb_r)) {\n    self.diry = -self.diry;\n    return;\n  }\n\n  if (isdiffdir(fdir, self.diry)) {\n    self.diry = fdir;\n    if (self.vy - dv >= 0) {\n      self.vy -= dv;\n    }\n    return;\n  }\n  if (self.vy + dv <= maxVy) {\n    self.vy += dv;\n  }\n}\n\n\nfunction controller(obj) {\n  let self = obj;\n\n  // scalr\n  let fx = 1;\n  let fy = 1;\n  let maxVx = 5;\n  let maxVy = 5;\n  return {\n    left: setvx.bind(self, self, -1, fx, maxVx),\n    right: setvx.bind(self, self, 1, fx, maxVx),\n    up: setvy.bind(self, self, -1, fy, maxVy),\n    down: setvy.bind(self, self, 1, fy, maxVy)\n  }\n}\nconst mybb1controller = controller(mybb1);\n/////\nfunction register() {\n  //if (!isRegistered) {\n  window.addEventListener(\"keydown\", function (evt) {\n    //console.log(e.keyCode);\n    // when keydown event emit, stepx(), stepy() should change direction\n    // as the keydown arrow key\n    // note: it should follow the boundary rule.\n    switch (evt.keyCode) {\n      case 37:\n        mybb1controller.left();\n        break;\n      case 38:\n        mybb1controller.up();\n        break;\n      case 39:\n        mybb1controller.right();\n        break;\n      case 40:\n        mybb1controller.down();\n        break;\n      // case 32: //SPACE (stop)\n      //   stop();\n      //   break;\n      // case 13: //ENTER (start)\n      //   start();\n      //   break;\n    }\n  }, false);\n\n  //isRegistered = true;\n\n  // stop recover isRegistered false\n  //}\n}\n\n\n\n// let state = {\n//   gb1: { x: gb1.gb_x, y: gb1.gb_y, r: gb1.gb_r },\n//   gb2: { x: gb2.gb_x, y: gb2.gb_y, r: gb2.gb_r },\n//   bb1: { x: bb1.bb_x, y: bb1.bb_y, r: bb1.bb_r, hp: bb1.hp },\n//   mybb1: { x: mybb1.bb_x, y: mybb1.bb_y, r: mybb1.bb_r, hp: mybb1.hp },\n// };\n// function stop(cancelId) {\n//   cancelAnimationFrame(cancelId);\n// }\n\n//////////RELOAD\n//HP: 100/ Red: 2\n/////////\nfunction start() {\n  clear(ctx);\n  gb1.render(ctx);\n  gb2.render(ctx);\n  bb1.render(ctx, gb1);\n  bb2.render(ctx, gb1);\n  mybb1.render(ctx, null);\n  // bb1.hp > 0 ? bb1.render(ctx, gb1) : null;\n  // bb2.hp > 0 ? bb2.render(ctx, gb1) : null;\n  // mybb1.hp > 0 ? mybb1.render(ctx, null) : null;\n  //let red = 2 - (bb1.hp > 0 ? 0 : 1) - (bb2.hp > 0 ? 0 : 1);\n  //if (red === 0) red += \"\\nDONE! PLEASE REFRESH(F5)\"\n  //scoreHtml.innerHTML = `HP: ${bb1.hp + bb2.hp}/ RED: ${red}`;\n  cancelId = requestAnimationFrame(start);\n}\n\nregister();\n//start();\nsetTimeout(start, 500);\n\n// when to end?\n// cancelAnimationFrame(cancelId);\n// hp  100 -> 150 => win\n// hp  100 -> 0  => lose","import {\n  step,\n  mutualcollision\n} from \"../helpers/movehelpers\";\nimport {\n  create,\n  clear,\n  transaction\n} from \"../helpers/ctxhelpers\";\nimport { xyrValiate } from \"../errors/error\";\n\n// gb - good ball\nclass GB {\n  constructor(ctx, x = 240, y = 160, r = 10, hp = 100) {\n    xyrValiate(x, y, r);\n    this.gb_x = x;\n    this.gb_y = y;\n    this.gb_r = r;\n    this.vx = 3;\n    this.vy = 3;\n    this.dirx = 1;\n    this.diry = 1;\n    this.hp = hp;\n    create(ctx, this.gb_x, this.gb_y, this.gb_r);\n  }\n  move() {\n    this.gb_x += step(this.gb_x, this.vx, this.dirx, this.gb_r, \"dirx\", this);\n    this.gb_y += step(this.gb_y, this.vy, this.diry, this.gb_r, \"diry\", this);\n  }\n  render(ctx) {\n    transaction(ctx, this.move.bind(this), this.gb_x, this.gb_y, this.gb_r);\n  }\n}\n\n// mp - magic power\n/////////////\n// bb - bad ball\nclass BB {\n  constructor(\n    ctx,\n    x = 240,\n    y = 160,\n    r = 10,\n    color = \"red\",\n    hp = 100,\n    detected = false\n  ) {\n    xyrValiate(x, y, r);\n    this.bb_x = x;\n    this.bb_y = y;\n    this.bb_r = r;\n    this.dirx = -1;\n    this.diry = 1;\n    this.vx = 1;\n    this.vy = 1;\n    this.color = color;\n    this.hp = hp;\n    this.detected = detected;\n    create(ctx, this.bb_x, this.bb_y, this.bb_r, this.color);\n  }\n\n  move() {\n    this.bb_x += step(this.bb_x, this.vx, this.dirx, this.bb_r, \"dirx\", this);\n    this.bb_y += step(this.bb_y, this.vy, this.diry, this.bb_r, \"diry\", this);\n  }\n  render(ctx, target = null) {\n    transaction(\n      ctx,\n      this.move.bind(this),\n      this.bb_x,\n      this.bb_y,\n      this.bb_r,\n      this.color\n    );\n    this.collision(this, target);\n  }\n  collision(source, target) {\n    if (this.detected && target !== null) {\n      this.hp = mutualcollision(source, target);\n    }\n  }\n}\n\n\n\nexport { GB, BB };\n"],"names":["step","d","v","dirVal","r","dirKey","obj","iscollide","dir","dd","create","ctx","x","y","color","beginPath","arc","Math","PI","fillStyle","fill","closePath","transaction","move","restore","args","save","xyrValiate","message","z","BaseError","isdiffdir","fdir","selfdir","setvx","self","fx","maxVx","dv","log","vx","dirx","bb_x","bb_r","setvy","fy","maxVy","diry","bb_y","vy","start","clearRect","render","gb1","requestAnimationFrame","captureStackTrace","Error","GB","hp","gb_x","gb_y","gb_r","this","bind","BB","detected","target","collision","source","bb1","dx2","pow","dy2","sqrt","mutualcollision","document","getElementById","canvas","getContext","cancelId","gb2","bb2","mybb1","mybb1controller","controller","addEventListener","evt","keyCode","left","up","right","down","setTimeout"],"mappings":"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"}